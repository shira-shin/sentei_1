<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Apple FSPM v17</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      background: #0f172a;
      color: #e2e8f0;
      font-family: "Inter", system-ui, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      touch-action: none;
    }
    #ui-layer {
      pointer-events: none;
    }
    #ui-layer > * {
      pointer-events: auto;
    }
    .glass {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 0 20px 60px rgba(15, 23, 42, 0.4);
      backdrop-filter: blur(12px);
    }
    input[type="range"] {
      accent-color: #38bdf8;
    }
  </style>
</head>
<body>
  <div id="ui-layer" class="fixed inset-0 z-10 p-6 flex flex-col justify-between relative">
    <div class="flex justify-between items-start gap-6">
      <div class="glass rounded-3xl p-6 w-[360px]">
        <div class="flex items-center justify-between mb-4">
          <h1 class="text-xl font-black tracking-tight">APPLE FSPM <span class="text-sky-400">v17</span></h1>
          <span id="season-badge" class="text-[10px] uppercase font-black px-3 py-1 rounded-full border border-slate-500">Dormant</span>
        </div>
        <div class="flex items-end gap-3 mb-6">
          <div id="day-display" class="text-5xl font-black font-mono">000</div>
          <div class="text-xs uppercase text-slate-400 font-semibold">Days</div>
        </div>
        <div class="space-y-4">
          <button id="btn-play" class="w-full py-3 rounded-2xl bg-sky-500 text-slate-900 font-bold hover:bg-sky-400 transition">Start</button>
          <div class="bg-slate-900/60 rounded-2xl p-4">
            <div class="flex justify-between text-[10px] uppercase font-black text-slate-400 mb-2">
              <span>Simulation Speed</span>
              <span id="speed-label">4x</span>
            </div>
            <input id="speed-slider" type="range" min="1" max="12" value="4" class="w-full" />
          </div>
          <div class="grid grid-cols-2 gap-2">
            <button id="btn-step" class="py-2 rounded-xl border border-slate-600 text-xs font-bold uppercase hover:bg-slate-800 transition">Step</button>
            <button id="btn-reset" class="py-2 rounded-xl border border-rose-500 text-xs font-bold uppercase text-rose-300 hover:bg-rose-900/40 transition">Reset</button>
          </div>
        </div>
      </div>

      <div id="physiology-dashboard" class="glass rounded-3xl p-6 w-[320px]">
        <h2 class="text-xs uppercase font-black text-slate-400 mb-4">Physiology Dashboard</h2>
        <div class="space-y-6">
          <div>
            <div class="flex justify-between text-[11px] font-black uppercase text-slate-300 mb-2">
              <span>樹勢メーター (Vigor)</span>
              <span id="vigor-val">0.80</span>
            </div>
            <div class="h-3 bg-slate-800 rounded-full overflow-hidden">
              <div id="vigor-bar" class="h-full bg-emerald-400" style="width: 80%"></div>
            </div>
          </div>
          <div>
            <div class="flex justify-between text-[11px] font-black uppercase text-slate-300 mb-2">
              <span>T/R Balance</span>
              <span id="tr-val">1.00</span>
            </div>
            <div class="flex h-3 bg-slate-800 rounded-full overflow-hidden">
              <div id="tr-shoot" class="h-full bg-indigo-400" style="width: 50%"></div>
              <div id="tr-root" class="h-full bg-amber-400" style="width: 50%"></div>
            </div>
          </div>
          <div>
            <div class="flex justify-between text-[11px] font-black uppercase text-slate-300 mb-2">
              <span>貯蔵養分タンク (NSC)</span>
              <span id="nsc-val">120</span>
            </div>
            <div class="h-3 bg-slate-800 rounded-full overflow-hidden">
              <div id="nsc-bar" class="h-full bg-sky-400" style="width: 60%"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="glass rounded-3xl p-6 w-[260px]">
        <h2 class="text-xs uppercase font-black text-slate-400 mb-4">剪定モード</h2>
        <button id="btn-prune" class="w-full py-3 rounded-2xl border border-amber-400 text-amber-200 font-bold uppercase hover:bg-amber-500/20 transition">Scissors: OFF</button>
        <p class="text-xs text-slate-400 mt-4 leading-relaxed">クリックした枝と子孫を削除し、樹勢とNSCを再計算します。</p>
      </div>
    </div>

    <div class="flex justify-between items-end">
      <div class="glass rounded-2xl p-4 max-w-lg text-sm text-slate-300" id="status-bar">Dormant phase: prune to unlock lateral buds.</div>
      <div class="text-xs uppercase text-slate-400 font-bold tracking-widest">Drag: Rotate · Wheel: Zoom · Click: Prune</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    const GOLDEN_ANGLE = THREE.MathUtils.degToRad(137.5);
    const AUXIN_DECAY = 0.72;
    const AUXIN_THRESHOLD = 0.6;
    const PIPE_EXPONENT = 2.5;

    const MAX_DAYS = 365;
    const PHENOLOGY = {
      leafStart: 90,
      leafEnd: 300,
      fruitStart: 120,
      fruitEnd: 280,
      maxFruitSize: 2.8
    };

    const SEASONS = [
      { name: "Dormant", start: 0, end: 90, color: "#94a3b8", msg: "Dormant phase: prune to unlock lateral buds." },
      { name: "Spring", start: 91, end: 180, color: "#38bdf8", msg: "Spring: buds activate and leaves emerge." },
      { name: "Summer", start: 181, end: 280, color: "#f59e0b", msg: "Summer: photosynthesis fuels vigor." },
      { name: "Autumn", start: 281, end: 330, color: "#f97316", msg: "Autumn: fruit matures and storage compounds accumulate." },
      { name: "Winter", start: 331, end: MAX_DAYS, color: "#38bdf8", msg: "Winter: leaf fall and pruning season." }
    ];

    class Metamer {
      constructor(parent = null, level = 0) {
        this.id = Math.random().toString(36).slice(2);
        this.parent = parent;
        this.children = [];
        this.level = level;
        this.length = 4.5 + Math.random() * 1.5;
        this.radius = 0.4;
        this.nsc = parent ? 0 : 120;
        this.auxin = 0;
        this.budActive = true;
        this.type = parent && level > 1 && Math.random() > 0.5 ? "spur" : "shoot";
        this.localQuat = new THREE.Quaternion();
        this.position = new THREE.Vector3();
        this.worldQuat = new THREE.Quaternion();
        this.mesh = null;
        this.budMesh = null;
        this.leafMesh = null;
        this.fruitMesh = null;
      }
    }

    let scene, camera, renderer, composer, controls, raycaster;
    let root = null;
    let metamerGroup = new THREE.Group();
    let day = 0;
    let isPlaying = false;
    let speed = 4;
    let pruneMode = false;
    let lastFrame = 0;
    let seasonComplete = false;

    const ui = {
      day: document.getElementById("day-display"),
      season: document.getElementById("season-badge"),
      status: document.getElementById("status-bar"),
      speed: document.getElementById("speed-slider"),
      speedLabel: document.getElementById("speed-label"),
      btnPlay: document.getElementById("btn-play"),
      btnStep: document.getElementById("btn-step"),
      btnReset: document.getElementById("btn-reset"),
      btnPrune: document.getElementById("btn-prune"),
      vigor: document.getElementById("vigor-val"),
      vigorBar: document.getElementById("vigor-bar"),
      tr: document.getElementById("tr-val"),
      trShoot: document.getElementById("tr-shoot"),
      trRoot: document.getElementById("tr-root"),
      nsc: document.getElementById("nsc-val"),
      nscBar: document.getElementById("nsc-bar")
    };

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color("#0f172a");

      camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(40, 55, 90);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.6, 0.1);
      composer.addPass(bloom);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const light = new THREE.DirectionalLight("#ffffff", 1.1);
      light.position.set(50, 120, 60);
      scene.add(light);
      scene.add(new THREE.AmbientLight("#94a3b8", 0.6));

      const grid = new THREE.GridHelper(200, 20, "#1e293b", "#1e293b");
      grid.position.y = 0;
      scene.add(grid);

      raycaster = new THREE.Raycaster();
      scene.add(metamerGroup);

      window.addEventListener("resize", onResize);
      renderer.domElement.addEventListener("pointerdown", onPointerDown);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function createTree() {
      root = new Metamer(null, 0);
      root.length = 8;
      root.localQuat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), 0);
      root.worldQuat.copy(root.localQuat);
      root.position.set(0, 0, 0);
      growInitial(root, 3);
      rebuildMeshes(day);
    }

    function growInitial(node, depth) {
      if (depth <= 0) return;
      const child = new Metamer(node, node.level + 1);
      child.localQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), 0.2);
      node.children.push(child);
      growInitial(child, depth - 1);
      for (let i = 0; i < 2; i++) {
        const lateral = new Metamer(node, node.level + 1);
        const spin = GOLDEN_ANGLE * (node.level + i + 1);
        const tilt = 0.8 + Math.random() * 0.3;
        const qTilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
        const qSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spin);
        lateral.localQuat.copy(qSpin).multiply(qTilt);
        node.children.push(lateral);
        growInitial(lateral, depth - 2);
      }
    }

    function updateWorldTransforms(node) {
      if (node.parent) {
        node.worldQuat.copy(node.parent.worldQuat).multiply(node.localQuat);
        const axis = new THREE.Vector3(0, 1, 0).applyQuaternion(node.parent.worldQuat).normalize();
        const offset = axis.multiplyScalar(node.parent.length);
        node.position.copy(node.parent.position).add(offset);
      }
      node.children.forEach((child) => updateWorldTransforms(child));
    }

    function computeAuxin(node) {
      let auxin = node.children.length === 0 ? 1 : 0;
      node.children.forEach((child) => {
        auxin += computeAuxin(child) * AUXIN_DECAY;
      });
      node.auxin = auxin;
      node.budActive = node.auxin < AUXIN_THRESHOLD || node.children.length === 0;
      return auxin;
    }

    function computePipeModel(node) {
      if (node.children.length === 0) {
        node.radius = 0.35;
        return Math.pow(node.radius, PIPE_EXPONENT);
      }
      let sum = 0;
      node.children.forEach((child) => {
        sum += computePipeModel(child);
      });
      node.radius = Math.pow(sum, 1 / PIPE_EXPONENT);
      return Math.pow(node.radius, PIPE_EXPONENT);
    }

    function rebuildMeshes(currentDay = day) {
      metamerGroup.clear();
      updateWorldTransforms(root);
      computeAuxin(root);
      computePipeModel(root);

      const stemMat = new THREE.MeshStandardMaterial({ color: "#8b5e34", roughness: 0.6 });
      const budActiveMat = new THREE.MeshStandardMaterial({ color: "#7dd3fc", emissive: "#38bdf8", emissiveIntensity: 1.2 });
      const budDormantMat = new THREE.MeshStandardMaterial({ color: "#475569", emissive: "#0f172a", emissiveIntensity: 0.2 });
      const leafMat = new THREE.MeshStandardMaterial({ color: "#2d5a27", side: THREE.DoubleSide, transparent: true, opacity: 0.0 });
      const fruitMat = new THREE.MeshStandardMaterial({ color: "#991b1b", roughness: 0.4 });

      const queue = [root];
      while (queue.length) {
        const node = queue.shift();
        const stemGeo = new THREE.CylinderGeometry(node.radius, node.parent ? node.parent.radius : node.radius * 1.2, node.length, 8);
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.userData.metamer = node;

        const center = node.position.clone();
        const axis = new THREE.Vector3(0, 1, 0).applyQuaternion(node.worldQuat).normalize();
        const mid = center.clone().add(axis.clone().multiplyScalar(node.length / 2));
        stem.position.copy(mid);
        stem.quaternion.copy(node.worldQuat);
        metamerGroup.add(stem);
        node.mesh = stem;

        const budGeo = new THREE.SphereGeometry(0.5, 12, 12);
        const bud = new THREE.Mesh(budGeo, node.budActive ? budActiveMat : budDormantMat);
        bud.position.copy(center.clone().add(axis.clone().multiplyScalar(node.length)));
        bud.userData.metamer = node;
        metamerGroup.add(bud);
        node.budMesh = bud;

        const leafGeo = new THREE.PlaneGeometry(3, 5);
        const leaf = new THREE.Mesh(leafGeo, leafMat.clone());
        leaf.position.copy(center.clone().add(axis.clone().multiplyScalar(node.length * 0.8)));
        leaf.quaternion.copy(node.worldQuat);
        leaf.rotateX(Math.PI / 2);
        metamerGroup.add(leaf);
        node.leafMesh = leaf;

        const fruitGeo = new THREE.SphereGeometry(1, 16, 16);
        const fruit = new THREE.Mesh(fruitGeo, fruitMat.clone());
        fruit.position.copy(center.clone().add(axis.clone().multiplyScalar(node.length * 0.9)));
        fruit.quaternion.copy(node.worldQuat);
        metamerGroup.add(fruit);
        node.fruitMesh = fruit;

        applyPhenology(node, currentDay);
        node.children.forEach((child) => queue.push(child));
      }
    }

    function updateSeasonUI(currentDay) {
      const season = SEASONS.find((s) => currentDay >= s.start && currentDay <= s.end) || SEASONS[0];
      ui.day.textContent = currentDay.toString().padStart(3, "0");
      ui.season.textContent = season.name;
      ui.season.style.borderColor = season.color;
      ui.season.style.color = season.color;
      ui.status.textContent = season.msg;
    }

    function endSeason() {
      if (seasonComplete) return;
      seasonComplete = true;
      isPlaying = false;
      ui.btnPlay.textContent = "Start";
      updateSeasonUI(MAX_DAYS);
      alert("一年が経過しました。冬季剪定を行ってください。");
    }

    function simulateDay() {
      if (day >= MAX_DAYS) {
        endSeason();
        return;
      }

      day += 1;
      if (day % 10 === 0) {
        growTree(root);
      }
      updatePhysiology();
      rebuildMeshes(day);
      updateSeasonUI(day);

      if (day >= MAX_DAYS) {
        endSeason();
      }
    }

    function growTree(node) {
      node.children.forEach((child) => growTree(child));
      if (!node.budActive) return;
      if (node.children.length > 2 || node.level > 6) return;
      if (Math.random() > 0.4) return;
      const lateral = new Metamer(node, node.level + 1);
      const spin = GOLDEN_ANGLE * (node.level + node.children.length + 1);
      const tilt = 0.6 + Math.random() * 0.6;
      const qTilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
      const qSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spin);
      lateral.localQuat.copy(qSpin).multiply(qTilt);
      node.children.push(lateral);
    }

    function updatePhysiology() {
      const metrics = { shootMass: 0, rootMass: 40, totalNsc: 0, budsActive: 0, budsDormant: 0 };
      traverse(root, (node) => {
        metrics.shootMass += node.length * node.radius;
        metrics.totalNsc += node.nsc;
        if (node.budActive) metrics.budsActive += 1; else metrics.budsDormant += 1;
      });
      const vigor = THREE.MathUtils.clamp(0.4 + metrics.budsActive / (metrics.budsDormant + metrics.budsActive + 1), 0.2, 1.0);
      const trRatio = metrics.shootMass / metrics.rootMass;
      ui.vigor.textContent = vigor.toFixed(2);
      ui.vigorBar.style.width = `${vigor * 100}%`;
      ui.tr.textContent = trRatio.toFixed(2);
      const shootPct = THREE.MathUtils.clamp(trRatio / (trRatio + 1), 0.2, 0.8) * 100;
      ui.trShoot.style.width = `${shootPct}%`;
      ui.trRoot.style.width = `${100 - shootPct}%`;
      ui.nsc.textContent = metrics.totalNsc.toFixed(0);
      ui.nscBar.style.width = `${THREE.MathUtils.clamp(metrics.totalNsc / 200, 0, 1) * 100}%`;
    }

    function applyPhenology(node, currentDay) {
      const leafVisible = currentDay >= PHENOLOGY.leafStart && currentDay <= PHENOLOGY.leafEnd;
      node.leafMesh.visible = leafVisible;
      if (leafVisible) {
        const leafProgress = THREE.MathUtils.clamp((currentDay - PHENOLOGY.leafStart) / 30, 0, 1);
        node.leafMesh.scale.setScalar(0.4 + leafProgress * 0.8);
        node.leafMesh.material.opacity = 0.25 + leafProgress * 0.6;
      }

      if (node.type === "spur" && currentDay >= PHENOLOGY.fruitStart && currentDay <= PHENOLOGY.fruitEnd) {
        node.fruitMesh.visible = true;
        const growthPeriod = currentDay - PHENOLOGY.fruitStart;
        const size = Math.min(PHENOLOGY.maxFruitSize, Math.cbrt(growthPeriod + 1) * 0.45);
        node.fruitMesh.scale.setScalar(size);
      } else {
        node.fruitMesh.visible = false;
      }
    }

    function traverse(node, fn) {
      fn(node);
      node.children.forEach((child) => traverse(child, fn));
    }

    function pruneNode(target) {
      if (!target || !target.parent) return;
      target.parent.children = target.parent.children.filter((child) => child !== target);
      updatePhysiology();
      rebuildMeshes(day);
    }

    function onPointerDown(event) {
      if (!pruneMode) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(metamerGroup.children, false);
      if (hits.length) {
        const metamer = hits[0].object.userData.metamer;
        pruneNode(metamer);
      }
    }

    function animate(timestamp) {
      requestAnimationFrame(animate);
      controls.update();
      if (isPlaying && timestamp - lastFrame > 600 / speed) {
        simulateDay();
        lastFrame = timestamp;
      }
      composer.render();
    }

    ui.speed.addEventListener("input", (event) => {
      speed = Number(event.target.value);
      ui.speedLabel.textContent = `${speed}x`;
    });

    ui.btnPlay.addEventListener("click", () => {
      isPlaying = !isPlaying;
      ui.btnPlay.textContent = isPlaying ? "Pause" : "Start";
    });

    ui.btnStep.addEventListener("click", () => simulateDay());

    ui.btnReset.addEventListener("click", () => {
      day = 0;
      seasonComplete = false;
      root = null;
      metamerGroup.clear();
      createTree();
      updatePhysiology();
      rebuildMeshes(day);
      updateSeasonUI(day);
    });

    ui.btnPrune.addEventListener("click", () => {
      pruneMode = !pruneMode;
      ui.btnPrune.textContent = `Scissors: ${pruneMode ? "ON" : "OFF"}`;
      ui.btnPrune.classList.toggle("bg-amber-500/20", pruneMode);
    });

    const dashboard = document.getElementById("physiology-dashboard");
    const uiLayer = document.getElementById("ui-layer");
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    function initDashboardDrag() {
      const rect = dashboard.getBoundingClientRect();
      const layerRect = uiLayer.getBoundingClientRect();
      dashboard.style.position = "absolute";
      dashboard.style.left = `${rect.left - layerRect.left}px`;
      dashboard.style.top = `${rect.top - layerRect.top}px`;
      dashboard.style.right = "auto";
      dashboard.style.bottom = "auto";
    }

    dashboard.addEventListener("pointerdown", (event) => {
      isDragging = true;
      dashboard.setPointerCapture(event.pointerId);
      const rect = dashboard.getBoundingClientRect();
      dragOffset = { x: event.clientX - rect.left, y: event.clientY - rect.top };
    });

    document.addEventListener("pointerup", () => {
      isDragging = false;
    });

    document.addEventListener("pointermove", (event) => {
      if (!isDragging) return;
      const layerRect = uiLayer.getBoundingClientRect();
      const nextLeft = event.clientX - layerRect.left - dragOffset.x;
      const nextTop = event.clientY - layerRect.top - dragOffset.y;
      dashboard.style.left = `${nextLeft}px`;
      dashboard.style.top = `${nextTop}px`;
      dashboard.style.right = "auto";
    });

    initScene();
    createTree();
    updatePhysiology();
    rebuildMeshes(day);
    updateSeasonUI(day);
    initDashboardDrag();
    animate();
  </script>
</body>
</html>
