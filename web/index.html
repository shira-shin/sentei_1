<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Apple FSPM v17</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      background: #0f172a;
      color: #e2e8f0;
      font-family: "Inter", system-ui, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      touch-action: none;
    }
    #ui-layer {
      pointer-events: none;
    }
    .ui-panel {
      pointer-events: auto;
    }
    .glass {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 0 20px 60px rgba(15, 23, 42, 0.4);
      backdrop-filter: blur(12px);
    }
    input[type="range"] {
      accent-color: #38bdf8;
    }
    body.prune-mode {
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 36 36'%3E%3Cpath d='M6 7l8 8m0 0l4-4m-4 4l-4 4m4-4l8 8' stroke='%23f59e0b' stroke-width='3' stroke-linecap='round'/%3E%3Ccircle cx='24' cy='10' r='5' fill='none' stroke='%23f59e0b' stroke-width='3'/%3E%3Ccircle cx='10' cy='24' r='5' fill='none' stroke='%23f59e0b' stroke-width='3'/%3E%3C/svg%3E") 12 12, crosshair;
    }
  </style>
</head>
<body>
  <div id="ui-layer" class="fixed inset-0 z-10 p-6 flex flex-col gap-6 relative">
    <div class="flex items-start gap-6">
      <div class="flex flex-col gap-4">
        <div class="glass rounded-3xl p-6 w-[360px] ui-panel">
          <div class="flex items-center justify-between mb-4">
            <h1 class="text-xl font-black tracking-tight">APPLE FSPM <span class="text-sky-400">v17</span></h1>
            <span id="season-badge" class="text-[10px] uppercase font-black px-3 py-1 rounded-full border border-slate-500">休眠期</span>
          </div>
          <div class="flex items-end gap-3 mb-6">
            <div id="day-display" class="text-5xl font-black font-mono">000</div>
            <div class="text-xs uppercase text-slate-400 font-semibold">日数</div>
          </div>
          <div class="space-y-4">
            <button id="btn-play" class="w-full py-3 rounded-2xl bg-sky-500 text-slate-900 font-bold hover:bg-sky-400 transition">開始</button>
            <div class="bg-slate-900/60 rounded-2xl p-4">
              <div class="flex justify-between text-[10px] uppercase font-black text-slate-400 mb-2">
                <span>1日あたりの秒数</span>
                <span id="speed-label">3.0s</span>
              </div>
              <input id="speed-slider" type="range" min="1" max="20" step="0.5" value="3" class="w-full" />
            </div>
            <div class="grid grid-cols-2 gap-2">
              <button id="btn-step" class="py-2 rounded-xl border border-slate-600 text-xs font-bold uppercase hover:bg-slate-800 transition">1日進める</button>
              <button id="btn-reset" class="py-2 rounded-xl border border-rose-500 text-xs font-bold uppercase text-rose-300 hover:bg-rose-900/40 transition">リセット</button>
            </div>
            <button id="btn-reset-view" class="w-full py-2 rounded-xl border border-slate-500 text-xs font-bold uppercase text-slate-200 hover:bg-slate-800 transition">視点リセット</button>
          </div>
        </div>

        <div class="glass rounded-3xl p-5 w-[360px] ui-panel">
          <h2 class="text-xs uppercase font-black text-slate-400 mb-3">剪定モード</h2>
          <button id="btn-prune" class="w-full py-3 rounded-2xl border border-amber-400 text-amber-200 font-bold uppercase hover:bg-amber-500/20 transition">剪定: OFF</button>
          <p class="text-xs text-slate-400 mt-3 leading-relaxed">クリックした枝と子孫を削除し、樹勢とNSCを再計算します。</p>
        </div>

        <div id="physiology-dashboard" class="glass rounded-3xl p-5 w-[360px] ui-panel">
          <h2 class="text-xs uppercase font-black text-slate-400 mb-4">生理ダッシュボード</h2>
          <div class="space-y-6">
            <div>
              <div class="flex justify-between text-[11px] font-black uppercase text-slate-300 mb-2">
                <span>樹勢メーター</span>
                <span id="vigor-val">0.80</span>
              </div>
              <div class="h-3 bg-slate-800 rounded-full overflow-hidden">
                <div id="vigor-bar" class="h-full bg-emerald-400" style="width: 80%"></div>
              </div>
            </div>
            <div>
              <div class="flex justify-between text-[11px] font-black uppercase text-slate-300 mb-2">
                <span>T/Rバランス</span>
                <span id="tr-val">1.00</span>
              </div>
              <div class="flex h-3 bg-slate-800 rounded-full overflow-hidden">
                <div id="tr-shoot" class="h-full bg-indigo-400" style="width: 50%"></div>
                <div id="tr-root" class="h-full bg-amber-400" style="width: 50%"></div>
              </div>
            </div>
            <div>
              <div class="flex justify-between text-[11px] font-black uppercase text-slate-300 mb-2">
                <span>貯蔵養分タンク</span>
                <span id="nsc-val">120</span>
              </div>
              <div class="h-3 bg-slate-800 rounded-full overflow-hidden">
                <div id="nsc-bar" class="h-full bg-sky-400" style="width: 60%"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="flex justify-between items-end gap-4 ui-panel">
      <div class="glass rounded-2xl p-4 max-w-lg text-sm text-slate-300" id="status-bar">休眠期: 剪定で側枝の芽を促します。</div>
      <div class="text-xs uppercase text-slate-400 font-bold tracking-widest">ドラッグ: 回転 · ホイール: ズーム · 右ドラッグ: 平行移動 · ダブルクリック: 視点リセット · クリック: 剪定</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    const GOLDEN_ANGLE = THREE.MathUtils.degToRad(137.5);
    const AUXIN_DECAY = 0.68;
    const AUXIN_THRESHOLD = 0.55;
    const PIPE_EXPONENT = 2.5;

    const MAX_DAYS = 365;
    const PHENOLOGY = {
      budBreakStart: 91,
      budBreakEnd: 150,
      extensionStart: 91,
      extensionEnd: 270,
      leafStart: 91,
      leafEnd: 360,
      fruitStart: 151,
      fruitEnd: 270,
      maxFruitSize: 3.2
    };

    const SEASONS = [
      { name: "冬", start: 0, end: 90, color: "#94a3b8", msg: "休眠期: 剪定で側枝の芽を促します。" },
      { name: "春", start: 91, end: 150, color: "#38bdf8", msg: "春: 芽が動き、葉が展開します。" },
      { name: "夏", start: 151, end: 270, color: "#f59e0b", msg: "夏: 枝の肥大と果実の発達期です。" },
      { name: "秋", start: 271, end: 360, color: "#f97316", msg: "秋: 成熟と落葉が進みます。" },
      { name: "冬", start: 361, end: MAX_DAYS, color: "#94a3b8", msg: "冬: 落葉後の剪定期です。" }
    ];

    class Metamer {
      constructor(parent = null, level = 0) {
        this.id = Math.random().toString(36).slice(2);
        this.parent = parent;
        this.children = [];
        this.level = level;
        this.length = 3.0 + Math.random() * 1.2;
        this.radius = 0.4;
        this.nsc = parent ? 0 : 120;
        this.auxin = 0;
        this.budActive = true;
        this.type = parent && level > 1 && Math.random() > 0.55 ? "spur" : "shoot";
        this.maxLength = this.length + (level < 2 ? 6 : 3) + Math.random() * 3;
        this.growthRate = 0.08 + Math.random() * 0.06;
        this.maxBudBurst = level < 2 ? 3 : level < 4 ? 2 : 1;
        this.budBurstCount = 0;
        this.leafCount = this.type === "spur" ? 3 + Math.floor(Math.random() * 2) : 4 + Math.floor(Math.random() * 3);
        this.leafLayout = Array.from({ length: this.leafCount }, (_, i) => ({
          spin: GOLDEN_ANGLE * (i + 1) + (Math.random() - 0.5) * 0.4,
          tilt: 0.3 + Math.random() * 0.5,
          offset: 0.55 + Math.random() * 0.25
        }));
        this.fruitingPotential = this.type === "spur" && Math.random() > 0.25;
        this.localQuat = new THREE.Quaternion();
        this.position = new THREE.Vector3();
        this.worldQuat = new THREE.Quaternion();
        this.mesh = null;
        this.budMesh = null;
        this.leafMeshes = [];
        this.fruitMesh = null;
      }
    }

    let scene, camera, renderer, composer, controls, raycaster;
    let root = null;
    let metamerGroup = new THREE.Group();
    let day = 0;
    let isPlaying = false;
    let secondsPerDay = 3;
    let pruneMode = false;
    let playbackTimer = null;
    let seasonComplete = false;
    let currentVigor = 0.8;
    let defaultCameraPosition = null;
    let defaultCameraTarget = null;

    const ui = {
      day: document.getElementById("day-display"),
      season: document.getElementById("season-badge"),
      status: document.getElementById("status-bar"),
      speed: document.getElementById("speed-slider"),
      speedLabel: document.getElementById("speed-label"),
      btnPlay: document.getElementById("btn-play"),
      btnStep: document.getElementById("btn-step"),
      btnReset: document.getElementById("btn-reset"),
      btnResetView: document.getElementById("btn-reset-view"),
      btnPrune: document.getElementById("btn-prune"),
      vigor: document.getElementById("vigor-val"),
      vigorBar: document.getElementById("vigor-bar"),
      tr: document.getElementById("tr-val"),
      trShoot: document.getElementById("tr-shoot"),
      trRoot: document.getElementById("tr-root"),
      nsc: document.getElementById("nsc-val"),
      nscBar: document.getElementById("nsc-bar")
    };

    secondsPerDay = Number(ui.speed.value);
    ui.speedLabel.textContent = `${secondsPerDay.toFixed(1)}s`;

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color("#0f172a");

      camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(32, 26, 52);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.6, 0.1);
      composer.addPass(bloom);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = true;
      controls.minDistance = 8;
      controls.maxDistance = 240;
      controls.maxPolarAngle = Math.PI * 0.85;
      controls.target.set(0, 0, 0);
      controls.update();
      defaultCameraPosition = camera.position.clone();
      defaultCameraTarget = controls.target.clone();

      const light = new THREE.DirectionalLight("#ffffff", 1.1);
      light.position.set(50, 120, 60);
      scene.add(light);
      scene.add(new THREE.AmbientLight("#94a3b8", 0.6));

      const grid = new THREE.GridHelper(200, 20, "#1e293b", "#1e293b");
      grid.position.y = 0;
      scene.add(grid);

      const groundGeo = new THREE.PlaneGeometry(220, 220);
      const groundMat = new THREE.MeshStandardMaterial({ color: "#0b1224", roughness: 1, metalness: 0 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      raycaster = new THREE.Raycaster();
      scene.add(metamerGroup);

      window.addEventListener("resize", onResize);
      renderer.domElement.addEventListener("pointerdown", onPointerDown);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function createTree() {
      root = new Metamer(null, 0);
      root.length = 8;
      root.localQuat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), 0);
      root.worldQuat.copy(root.localQuat);
      root.position.set(0, 0, 0);
      growInitial(root, 3);
      rebuildMeshes(day);
      frameTreeView();
    }

    function growInitial(node, depth) {
      if (depth <= 0) return;
      const child = new Metamer(node, node.level + 1);
      child.localQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), 0.2);
      node.children.push(child);
      growInitial(child, depth - 1);
      for (let i = 0; i < 2; i++) {
        const lateral = new Metamer(node, node.level + 1);
        const spin = GOLDEN_ANGLE * (node.level + i + 1);
        const tilt = 0.8 + Math.random() * 0.3;
        const qTilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
        const qSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spin);
        const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), (Math.random() - 0.5) * 0.6);
        lateral.localQuat.copy(qSpin).multiply(qTilt).multiply(qRoll);
        node.children.push(lateral);
        growInitial(lateral, depth - 2);
      }
    }

    function updateWorldTransforms(node) {
      if (node.parent) {
        node.worldQuat.copy(node.parent.worldQuat).multiply(node.localQuat);
        const axis = new THREE.Vector3(0, 1, 0).applyQuaternion(node.parent.worldQuat).normalize();
        const offset = axis.multiplyScalar(node.parent.length);
        node.position.copy(node.parent.position).add(offset);
      }
      node.children.forEach((child) => updateWorldTransforms(child));
    }

    function computeAuxin(node) {
      let auxin = node.children.length === 0 ? 1 : 0;
      node.children.forEach((child) => {
        auxin += computeAuxin(child) * AUXIN_DECAY;
      });
      node.auxin = auxin;
      node.budActive = node.auxin < AUXIN_THRESHOLD || node.children.length === 0;
      return auxin;
    }

    function computePipeModel(node) {
      if (node.children.length === 0) {
        node.radius = 0.35;
        return Math.pow(node.radius, PIPE_EXPONENT);
      }
      let sum = 0;
      node.children.forEach((child) => {
        sum += computePipeModel(child);
      });
      node.radius = Math.pow(sum, 1 / PIPE_EXPONENT);
      return Math.pow(node.radius, PIPE_EXPONENT);
    }

    function rebuildMeshes(currentDay = day) {
      metamerGroup.clear();
      updateWorldTransforms(root);
      computeAuxin(root);
      computePipeModel(root);

      const stemMat = new THREE.MeshStandardMaterial({ color: "#8b5e34", roughness: 0.6 });
      const budActiveMat = new THREE.MeshStandardMaterial({ color: "#a3e635", emissive: "#84cc16", emissiveIntensity: 1.8 });
      const budDormantMat = new THREE.MeshStandardMaterial({ color: "#475569", emissive: "#0f172a", emissiveIntensity: 0.2 });
      const leafMat = new THREE.MeshStandardMaterial({ color: "#2d5a27", side: THREE.DoubleSide, transparent: true, opacity: 0.0 });
      const fruitMat = new THREE.MeshStandardMaterial({ color: "#991b1b", roughness: 0.4 });

      const queue = [root];
      while (queue.length) {
        const node = queue.shift();
        const stemGeo = new THREE.CylinderGeometry(node.radius, node.parent ? node.parent.radius : node.radius * 1.2, node.length, 8);
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.userData.metamer = node;

        const center = node.position.clone();
        const axis = new THREE.Vector3(0, 1, 0).applyQuaternion(node.worldQuat).normalize();
        const mid = center.clone().add(axis.clone().multiplyScalar(node.length / 2));
        stem.position.copy(mid);
        stem.quaternion.copy(node.worldQuat);
        metamerGroup.add(stem);
        node.mesh = stem;

        const budGeo = new THREE.SphereGeometry(0.5, 12, 12);
        const bud = new THREE.Mesh(budGeo, node.budActive ? budActiveMat : budDormantMat);
        bud.position.copy(center.clone().add(axis.clone().multiplyScalar(node.length)));
        bud.userData.metamer = node;
        metamerGroup.add(bud);
        node.budMesh = bud;

        const leafGeo = new THREE.PlaneGeometry(3, 5);
        node.leafMeshes = [];
        node.leafLayout.forEach((layout) => {
          const leaf = new THREE.Mesh(leafGeo, leafMat.clone());
          leaf.position.copy(center.clone().add(axis.clone().multiplyScalar(node.length * layout.offset)));
          leaf.quaternion.copy(node.worldQuat);
          leaf.rotateX(Math.PI / 2);
          leaf.rotateY(layout.spin);
          leaf.rotateZ(layout.tilt);
          metamerGroup.add(leaf);
          node.leafMeshes.push(leaf);
        });

        const fruitGeo = new THREE.SphereGeometry(1, 16, 16);
        const fruit = new THREE.Mesh(fruitGeo, fruitMat.clone());
        fruit.position.copy(center.clone().add(axis.clone().multiplyScalar(node.length * 0.9)));
        fruit.quaternion.copy(node.worldQuat);
        metamerGroup.add(fruit);
        node.fruitMesh = fruit;

        applyPhenology(node, currentDay);
        node.children.forEach((child) => queue.push(child));
      }
    }

    function updateSeasonUI(currentDay) {
      const season = SEASONS.find((s) => currentDay >= s.start && currentDay <= s.end) || SEASONS[0];
      ui.day.textContent = currentDay.toString().padStart(3, "0");
      ui.season.textContent = season.name;
      ui.season.style.borderColor = season.color;
      ui.season.style.color = season.color;
      ui.status.textContent = season.msg;
    }

    function endSeason() {
      if (seasonComplete) return;
      seasonComplete = true;
      isPlaying = false;
      stopPlaybackTimer();
      ui.btnPlay.textContent = "開始";
      updateSeasonUI(MAX_DAYS);
      alert("一年が経過しました。冬季剪定を行ってください。");
    }

    function simulateDay() {
      if (day >= MAX_DAYS) {
        endSeason();
        return;
      }

      day += 1;
      computeAuxin(root);
      growTree(root);
      updatePhysiology();
      rebuildMeshes(day);
      updateSeasonUI(day);

      if (day >= MAX_DAYS) {
        endSeason();
      }
    }

    function growTree(node) {
      node.children.forEach((child) => growTree(child));
      const extensionPhase = day >= PHENOLOGY.extensionStart && day <= PHENOLOGY.extensionEnd;
      if (extensionPhase) {
        const seasonProgress = (day - PHENOLOGY.extensionStart) / (PHENOLOGY.extensionEnd - PHENOLOGY.extensionStart);
        const growthPulse = Math.sin(Math.PI * seasonProgress);
        const vigorFactor = THREE.MathUtils.clamp(currentVigor, 0.3, 1.1);
        node.length = Math.min(node.maxLength, node.length + node.growthRate * growthPulse * vigorFactor);
      }

      const budBreakPhase = day >= PHENOLOGY.budBreakStart && day <= PHENOLOGY.budBreakEnd;
      if (!budBreakPhase || !node.budActive) return;
      if (node.level > 6) return;
      if (node.budBurstCount >= node.maxBudBurst) return;
      const maxChildren = node.level < 2 ? 4 : node.level < 4 ? 3 : 2;
      if (node.children.length >= maxChildren) return;

      const auxinFactor = THREE.MathUtils.clamp(1.05 - node.auxin * 0.65, 0.2, 1.0);
      const levelFactor = THREE.MathUtils.clamp(1.0 - node.level * 0.12, 0.35, 1.0);
      const budBurstChance = 0.22 * auxinFactor * levelFactor * currentVigor;
      if (Math.random() > budBurstChance) return;

      const lateral = new Metamer(node, node.level + 1);
      const spin = GOLDEN_ANGLE * (node.level + node.children.length + 1);
      const tilt = 0.6 + Math.random() * 0.6;
      const qTilt = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
      const qSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spin);
      const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), (Math.random() - 0.5) * 0.6);
      lateral.localQuat.copy(qSpin).multiply(qTilt).multiply(qRoll);
      node.children.push(lateral);
      node.budBurstCount += 1;
    }

    function updatePhysiology() {
      const metrics = { shootMass: 0, rootMass: 40, totalNsc: 0, budsActive: 0, budsDormant: 0 };
      traverse(root, (node) => {
        metrics.shootMass += node.length * node.radius;
        metrics.totalNsc += node.nsc;
        if (node.budActive) metrics.budsActive += 1; else metrics.budsDormant += 1;
      });
      const vigor = THREE.MathUtils.clamp(0.4 + metrics.budsActive / (metrics.budsDormant + metrics.budsActive + 1), 0.2, 1.0);
      currentVigor = vigor;
      const trRatio = metrics.shootMass / metrics.rootMass;
      ui.vigor.textContent = vigor.toFixed(2);
      ui.vigorBar.style.width = `${vigor * 100}%`;
      ui.tr.textContent = trRatio.toFixed(2);
      const shootPct = THREE.MathUtils.clamp(trRatio / (trRatio + 1), 0.2, 0.8) * 100;
      ui.trShoot.style.width = `${shootPct}%`;
      ui.trRoot.style.width = `${100 - shootPct}%`;
      ui.nsc.textContent = metrics.totalNsc.toFixed(0);
      ui.nscBar.style.width = `${THREE.MathUtils.clamp(metrics.totalNsc / 200, 0, 1) * 100}%`;
    }

    function applyPhenology(node, currentDay) {
      const leafVisible = currentDay >= PHENOLOGY.leafStart && currentDay <= PHENOLOGY.leafEnd;
      node.leafMeshes.forEach((leaf) => {
        leaf.visible = leafVisible;
        if (leafVisible) {
          const leafProgress = THREE.MathUtils.clamp((currentDay - PHENOLOGY.leafStart) / 35, 0, 1);
          const fallProgress = currentDay >= 271 ? THREE.MathUtils.clamp((currentDay - 271) / 40, 0, 1) : 0;
          leaf.scale.setScalar(0.5 + leafProgress * 0.9 * (1 - fallProgress * 0.4));
          leaf.material.opacity = 0.2 + leafProgress * 0.65 * (1 - fallProgress);
        }
      });

      if (node.fruitingPotential && currentDay >= PHENOLOGY.fruitStart && currentDay <= PHENOLOGY.fruitEnd) {
        node.fruitMesh.visible = true;
        const growthPeriod = currentDay - PHENOLOGY.fruitStart;
        const size = Math.min(PHENOLOGY.maxFruitSize, Math.cbrt(growthPeriod + 1) * 0.45);
        node.fruitMesh.scale.setScalar(size);
      } else {
        node.fruitMesh.visible = false;
      }
    }

    function traverse(node, fn) {
      fn(node);
      node.children.forEach((child) => traverse(child, fn));
    }

    function pruneNode(target) {
      if (!target || !target.parent) return;
      target.parent.children = target.parent.children.filter((child) => child !== target);
      updatePhysiology();
      rebuildMeshes(day);
    }

    function onPointerDown(event) {
      if (!pruneMode) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(metamerGroup.children, false);
      if (hits.length) {
        const metamer = hits[0].object.userData.metamer;
        pruneNode(metamer);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      composer.render();
    }

    function startPlaybackTimer() {
      stopPlaybackTimer();
      if (seasonComplete || day >= MAX_DAYS) return;
      playbackTimer = window.setInterval(() => {
        if (!isPlaying) return;
        simulateDay();
        if (seasonComplete || day >= MAX_DAYS) {
          stopPlaybackTimer();
        }
      }, secondsPerDay * 1000);
    }

    function stopPlaybackTimer() {
      if (playbackTimer) {
        window.clearInterval(playbackTimer);
        playbackTimer = null;
      }
    }

    function resetSimulation() {
      day = 0;
      seasonComplete = false;
      stopPlaybackTimer();
      root = null;
      metamerGroup.clear();
      createTree();
      updatePhysiology();
      updateSeasonUI(day);
    }

    function frameTreeView() {
      if (!metamerGroup || metamerGroup.children.length === 0) return;
      const box = new THREE.Box3().setFromObject(metamerGroup);
      if (box.isEmpty()) return;
      const center = box.getCenter(new THREE.Vector3());
      const rootFocus = root ? root.position.clone() : center.clone();
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = Math.max(18, maxDim * 2.4);
      const viewDir = new THREE.Vector3(0.7, 0.6, 1).normalize();
      camera.position.copy(rootFocus.clone().add(viewDir.multiplyScalar(distance)));
      controls.target.copy(rootFocus);
      controls.update();
      defaultCameraPosition = camera.position.clone();
      defaultCameraTarget = controls.target.clone();
    }

    ui.speed.addEventListener("input", (event) => {
      secondsPerDay = Number(event.target.value);
      ui.speedLabel.textContent = `${secondsPerDay.toFixed(1)}s`;
      if (isPlaying) {
        startPlaybackTimer();
      }
    });

    ui.btnPlay.addEventListener("click", () => {
      if (seasonComplete || day >= MAX_DAYS) {
        resetSimulation();
      }
      isPlaying = !isPlaying;
      if (isPlaying) {
        startPlaybackTimer();
      } else {
        stopPlaybackTimer();
      }
      ui.btnPlay.textContent = isPlaying ? "一時停止" : "開始";
    });

    ui.btnStep.addEventListener("click", () => simulateDay());

    ui.btnReset.addEventListener("click", () => {
      resetSimulation();
    });

    ui.btnResetView.addEventListener("click", () => resetCameraView());

    ui.btnPrune.addEventListener("click", () => {
      pruneMode = !pruneMode;
      ui.btnPrune.textContent = `剪定: ${pruneMode ? "ON" : "OFF"}`;
      ui.btnPrune.classList.toggle("bg-amber-500/20", pruneMode);
      document.body.classList.toggle("prune-mode", pruneMode);
    });

    function resetCameraView() {
      if (!defaultCameraPosition || !defaultCameraTarget) return;
      camera.position.copy(defaultCameraPosition);
      controls.target.copy(defaultCameraTarget);
      controls.update();
    }

    document.addEventListener("dblclick", () => resetCameraView());

    initScene();
    createTree();
    updatePhysiology();
    updateSeasonUI(day);
    animate();
  </script>
</body>
</html>
